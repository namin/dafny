using System;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Dafny;
using Xunit;

public class InductiveProofSketcherTests {

    [Fact]
    public async Task TestGenerateProofSketchWithPatternMatching() {
        var programText = @"
    module TestModule {
        datatype option<A> = None | Some(get: A)
        datatype ty = TBase | TArrow(T1: ty, T2: ty)
        datatype tm = tvar(id: int) 
                    | tabs(x: int, T: ty, body: tm) 
                    | tapp(f: tm, arg: tm)

        function has_type(c: map<int, ty>, t: tm): option<ty>
        decreases t
        {
            match t
            case tvar(id) => if id in c then Some(c[id]) else None
            case tabs(x, T, body) =>
                var ty_body := has_type(c[x := T], body);
                if ty_body.Some? then Some(TArrow(T, ty_body.get)) else None
            case tapp(f, arg) =>
                var ty_f := has_type(c, f);
                var ty_arg := has_type(c, arg);
                if ty_f.Some? && ty_arg.Some? && ty_f.get.TArrow? && ty_f.get.T1 == ty_arg.get then
                    Some(ty_f.get.T2)
                else None
        }

        function subst(x: int, replacement: tm, t: tm): tm {
            match t
            case tvar(id) => if id == x then replacement else t
            case tabs(id, ty, body) => tabs(id, ty, if id == x then body else subst(x, replacement, body))
            case tapp(f, arg) => tapp(subst(x, replacement, f), subst(x, replacement, arg))
        }

        lemma TestMethod(t: tm, c: map<int, ty>)
            requires has_type(c, t).Some?;
            ensures  true;
        {
            // Proof body to be generated by the sketcher
        }
    }";

        var proofSketch = await SetupAndGenerateProofSketch(programText, "TestMethod");

        Assert.Contains("TestMethod(f, c)", proofSketch);
        Assert.Contains("TestMethod(arg, c)", proofSketch);
        Assert.Contains("TestMethod(body, c[x := T])", proofSketch);
    }

    [Fact]
    public async Task TestGenerateProofSketchNatMethod() {
        var programText = @"
        method TestMethod(n: nat)
            requires n > 0
            ensures n == n // Dummy postcondition
        {
            // Body can be empty or contain code.
        }
        ";
        var proofSketch = await SetupAndGenerateProofSketch(programText, "TestMethod");
        Assert.Contains("n == 0", proofSketch); // Check for the base case
        Assert.Contains("n - 1", proofSketch); // Check for the inductive step
    }


    [Fact]
    public async Task TestGenerateProofSketchDatatypeExpr() {
        var programText = @"
        datatype Expr = constant(c: int) | variable(x: string) | plus(e1: Expr, e2: Expr) | times(e1: Expr, e2: Expr)
        method TestMethod(e: Expr)
        {
        }
        ";
        var proofSketch = await SetupAndGenerateProofSketch(programText, "TestMethod");
        Assert.Contains("constant", proofSketch);
        Assert.Contains("variable", proofSketch);
        Assert.Contains("plus", proofSketch);
        Assert.Contains("times", proofSketch);
    }

    [Fact]
    public async Task TestGenerateProofSketchNat() {
        var programText = @"
module TestModule {
    lemma TestMethod(n: nat)
        ensures true
    {
        // Proof body to be generated by the sketcher
    }
}
        ";

        var proofSketch = await SetupAndGenerateProofSketch(programText, "TestMethod");

        Assert.Contains("if (n == 0)", proofSketch);
        Assert.Contains("else", proofSketch);
        Assert.Contains("TestMethod(n - 1);", proofSketch);
    }

    [Fact]
    public async Task TestGenerateProofSketchDatatype() {
        var programText = @"
module TestModule {
    datatype Nat = Zero | Succ(pred: Nat)

    lemma TestMethod(n: Nat)
        ensures true
    {
        // Proof body to be generated by the sketcher
    }
}
        ";

        var proofSketch = await SetupAndGenerateProofSketch(programText, "TestMethod");

        Assert.Contains("match n {", proofSketch);
        Assert.Contains("case Zero() => {", proofSketch);
        Assert.Contains("case Succ(pred) => {", proofSketch);
        Assert.Contains("TestMethod(pred);", proofSketch);
    }

    [Fact]
    public async Task TestFunctionBasedInduction() {
        var programText = @"
    module TestModule {
        function IsEven(n: nat): bool {
            if n == 0 then true
            else if n == 1 then false
            else IsEven(n - 2)
        }
        lemma TestMethod(n: nat)
            requires IsEven(n)
            ensures true
        {
            // Proof body to be generated by the sketcher
        }
    }";
        var proofSketch = await SetupAndGenerateProofSketch(programText, "TestMethod");

        Assert.Contains("if (n == 0)", proofSketch);
        Assert.Contains("else if (n == 1)", proofSketch);
        Assert.Contains("else {", proofSketch);
        Assert.Contains("TestMethod(n - 2);", proofSketch);
    }

    private async Task<string> SetupAndGenerateProofSketch(string programText, string lemmaName) {
        // Initialize the error reporter
        var inputReader = new StringReader("");  // Empty input for now
        var outputWriter = new StringWriter();
        var errorWriter = new StringWriter();
        var options = new DafnyOptions(inputReader, outputWriter, errorWriter);
        var reporter = new ConsoleErrorReporter(options);

        Uri uri = new Uri("file:///test.dfy");
        var program = await new ProgramParser().Parse(programText, uri, reporter);

        if (reporter.ErrorCount > 0) {
            var errors = string.Join("\n", reporter.AllMessages);
            throw new Exception($"Parsing failed with {reporter.ErrorCount} error(s):\n{errors}");
        }

        var resolver = new ProgramResolver(program);
        await resolver.Resolve(System.Threading.CancellationToken.None);

        if (reporter.ErrorCount > 0) {
            var errors = string.Join("\n", reporter.AllMessages);
            throw new Exception($"Resolving failed with {reporter.ErrorCount} error(s):\n{errors}");
        }

        var lemma = FindMethodByName(program.DefaultModuleDef.TopLevelDecls, lemmaName);
        Assert.NotNull(lemma);

        var sketcher = new InductiveProofSketcher(reporter);
        var proofSketch = sketcher.GenerateProofSketch(lemma, 0);
        return proofSketch;
    }

    private Method? FindMethodByName(IEnumerable<TopLevelDecl> decls, string methodName) {
        foreach (var decl in decls) {
            if (decl is LiteralModuleDecl moduleDecl) {
                var innerDecls = moduleDecl.ModuleDef.TopLevelDecls;
                var result = FindMethodByName(innerDecls, methodName);
                if (result != null) {
                    return result;
                }
            } else if (decl is TopLevelDeclWithMembers membersDecl) {
                foreach (var member in membersDecl.Members) {
                    if (member is Method method && method.Name == methodName) {
                        return method;
                    }
                }
            }
        }
        return null;
    }
}