using System;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Dafny;
using Xunit;

public class InductiveProofSketcherTests {

    [Fact]
    public async Task TestGenerateProofSketchNatMethod() {
        var programText = @"
        method TestMethod(n: nat)
            requires n > 0
            ensures n == n // Dummy postcondition
        {
            // Body can be empty or contain code.
        }
        ";
        var proofSketch = await SetupAndGenerateProofSketch(programText, "TestMethod");
        Assert.Contains("n == 0", proofSketch); // Check for the base case
        Assert.Contains("n - 1", proofSketch); // Check for the inductive step
    }


    [Fact]
    public async Task TestGenerateProofSketchDatatypeExpr() {
        var programText = @"
        datatype Expr = constant(c: int) | variable(x: string) | plus(e1: Expr, e2: Expr) | times(e1: Expr, e2: Expr)
        method TestMethod(e: Expr)
        {
        }
        ";
        var proofSketch = await SetupAndGenerateProofSketch(programText, "TestMethod");
        Assert.Contains("constant", proofSketch);
        Assert.Contains("variable", proofSketch);
        Assert.Contains("plus", proofSketch);
        Assert.Contains("times", proofSketch);
    }

    [Fact]
    public async Task TestGenerateProofSketchNat() {
        var programText = @"
module TestModule {
    lemma TestMethod(n: nat)
        ensures true
    {
        // Proof body to be generated by the sketcher
    }
}
        ";

        var proofSketch = await SetupAndGenerateProofSketch(programText, "TestMethod");

        Assert.Contains("if (n == 0)", proofSketch);
        Assert.Contains("else", proofSketch);
        Assert.Contains("TestMethod(n - 1);", proofSketch);
    }

    [Fact]
    public async Task TestGenerateProofSketchDatatype() {
        var programText = @"
module TestModule {
    datatype Nat = Zero | Succ(pred: Nat)

    lemma TestMethod(n: Nat)
        ensures true
    {
        // Proof body to be generated by the sketcher
    }
}
        ";

        var proofSketch = await SetupAndGenerateProofSketch(programText, "TestMethod");

        Assert.Contains("match n {", proofSketch);
        Assert.Contains("case Zero() => {", proofSketch);
        Assert.Contains("case Succ(pred) => {", proofSketch);
        Assert.Contains("TestMethod(pred);", proofSketch);
    }

    [Fact]
    public async Task TestFunctionBasedInduction() {
        var programText = @"
    module TestModule {
        function IsEven(n: nat): bool {
            if n == 0 then true
            else if n == 1 then false
            else IsEven(n - 2)
        }
        lemma TestMethod(n: nat)
            requires IsEven(n)
            ensures true
        {
            // Proof body to be generated by the sketcher
        }
    }";
        var proofSketch = await SetupAndGenerateProofSketch(programText, "TestMethod");

        Assert.Contains("if (n == 0)", proofSketch);
        Assert.Contains("else if (n == 1)", proofSketch);
        Assert.Contains("else {", proofSketch);
        Assert.Contains("TestMethod(n - 2);", proofSketch);
    }

    private async Task<string> SetupAndGenerateProofSketch(string programText, string lemmaName) {
        // Initialize the error reporter
        var inputReader = new StringReader("");  // Empty input for now
        var outputWriter = new StringWriter();
        var errorWriter = new StringWriter();
        var options = new DafnyOptions(inputReader, outputWriter, errorWriter);
        var reporter = new ConsoleErrorReporter(options);

        Uri uri = new Uri("file:///test.dfy");
        var program = await new ProgramParser().Parse(programText, uri, reporter);

        if (reporter.ErrorCount > 0) {
            var errors = string.Join("\n", reporter.AllMessages);
            throw new Exception($"Parsing failed with {reporter.ErrorCount} error(s):\n{errors}");
        }

        var resolver = new ProgramResolver(program);
        await resolver.Resolve(System.Threading.CancellationToken.None);

        if (reporter.ErrorCount > 0) {
            var errors = string.Join("\n", reporter.AllMessages);
            throw new Exception($"Resolving failed with {reporter.ErrorCount} error(s):\n{errors}");
        }

        var lemma = FindMethodByName(program.DefaultModuleDef.TopLevelDecls, lemmaName);
        Assert.NotNull(lemma);

        var sketcher = new InductiveProofSketcher(reporter);
        var proofSketch = sketcher.GenerateProofSketch(lemma, 0);
        return proofSketch;
    }

    private Method? FindMethodByName(IEnumerable<TopLevelDecl> decls, string methodName) {
        foreach (var decl in decls) {
            if (decl is LiteralModuleDecl moduleDecl) {
                var innerDecls = moduleDecl.ModuleDef.TopLevelDecls;
                var result = FindMethodByName(innerDecls, methodName);
                if (result != null) {
                    return result;
                }
            } else if (decl is TopLevelDeclWithMembers membersDecl) {
                foreach (var member in membersDecl.Members) {
                    if (member is Method method && method.Name == methodName) {
                        return method;
                    }
                }
            }
        }
        return null;
    }
}